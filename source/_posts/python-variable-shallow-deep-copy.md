---
title: python 변수, 참조, shallow copy, deep copy
tags:
  - variable
  - copy
  - shallow copy
  - deep copy
categories:
  - python
date: 2018-02-12 22:40:26
updated: 2018-02-12 22:40:26
---

* 이해하지 못했었던 shallow copy와 deep copy를 정리해봤다.
* 막연하게 알고 있던 것과 많이 달랐다.
* 신기한 python(...)

## 변수와 데이터
```py
In [1]: a = 1

In [2]: b = a

In [3]: id(a)
Out[3]: 499102784

In [4]: id(b)
Out[4]: 499102784

In [5]: b = 2

In [6]: a
Out[6]: 1

In [7]: b
Out[7]: 2

In [8]: id(a)
Out[8]: 499102784

In [9]: id(b)
Out[9]: 499102816

In [10]: b = 1

In [11]: id(b)
Out[11]: 499102784
```
* `b = a`를 실행했을 때 b를 a의 별명으로 설정한 것이다.
* 즉, b와 a는 모두 같은 메모리 주소에 연결되어 있다. 참조 값의 할당이라고 한다.
* b에 새로운 값을 대입하는 순간 b가 가리키는 주소가 변경된다.
* b에 다시 1을 대입하면 a와 동일한 주소를 가리키게 된다.
* C언어의 경우 `b = a`를 수행하면 b는 a와 다른 별도의 메모리 공간이 할당되고 값이 복사된다.
* 파이썬의 경우 a와 b에 각각 다른 값을 할당하면 a, b의 주소가 변경된다.
* 정수 타입은 immutable이므로 같은 주소의 데이터가 바뀌지 않는다.
* C언어의 경우 a와 b에 각각 다른 값을 할당하면 동일한 주소에 데이터만 변경된다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: id(a)
Out[3]: 77505736

In [4]: id(b)
Out[4]: 77505736

In [5]: b
Out[5]: [1, 2, 3, 4]

In [6]: b[1] = 100

In [7]: id(a)
Out[7]: 77505736

In [8]: id(b)
Out[8]: 77505736

In [9]: a
Out[9]: [1, 100, 3, 4]

In [10]: b
Out[10]: [1, 100, 3, 4]

In [11]: a is b
Out[11]: True
```
* a는 list다.
* `b = a`를 실행하면 a와 b는 동일한 주소를 가리킨다.
* b[1]의 데이터를 변경하면 a[1]도 같이 변경되는 것 처럼 보인다.
* 이것은 b[1]의 값을 변경했다기보다 b[1]이 가리키고 있는 주소가 변경되었고 그 주소에 100이 저장된 것이다.
* b[1]의 데이터가 변경되어도 b 자체의 주소는 변경되지 않는다.
* a와 b가 같은 실체를 기리키고 있는지는 is 연산자를 이용해서도 확인할 수 있다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: a is b
Out[3]: True

In [4]: b = [1, 2, 3, 5]

In [5]: a is b
Out[5]: False

In [6]: b = [1, 2, 3, 4]

In [7]: a is b
Out[7]: False

In [8]: a = [1, 2, 3, 4]

In [9]: b = a

In [10]: a is b
Out[10]: True

In [11]: b = [1, 2, 3, 4]

In [12]: a is b
Out[12]: False
```
* 인덱싱을 통해 데이터의 일부를 변경하는 경우와는 달리 인덱싱이나 슬라이싱이 아닌 재할당을 하는 경우 변수가 새롭게 정의된다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = a

In [3]: a is b
Out[3]: True

In [4]: b[:] = [5, 6, 7, 8]

In [5]: a is b
Out[5]: True
```
* 인덱싱이나 슬라이싱을 사용한 할당문으로 처리할 경우 b가 재정의 되지 않는다.

```py
In [1]: a = [1, 2, 3, 4]

In [2]: b = [1, 2, 3, 4]

In [3]: a == b
Out[3]: True

In [4]: a is b
Out[4]: False

In [5]: [id(k) for k in a]
Out[5]: [495170624, 495170656, 495170688, 495170720]

In [6]: [id(k) for k in b]
Out[6]: [495170624, 495170656, 495170688, 495170720]

In [7]: b[1] = 10

In [8]: a
Out[8]: [1, 2, 3, 4]

In [9]: b
Out[9]: [1, 10, 3, 4]

In [10]: [id(k) for k in b]
Out[10]: [495170624, 495170912, 495170688, 495170720]
```
* a와 b의 값이 동일하다. 하지만 a, b 자체의 identity 값은 다르다.
* a, b 각 요소의 identity 값은 동일하다.
* a, b 자체의 identity 값이 다르므로 b[1]의 값을 변경해도 a에는 영향을 주지 않는다.

## 얕은 복사와 깊은 복사
* 얕은 복사: 참조만 복사
* 깊은 복사: 데이터까지 완전히 복사
* 얕은 복사와 깊은 복사의 차이가 드러나는 경우는 컨테이너 타입이나 클래스 인스턴스처럼 내부에 객체를 포함하는 복합 객체를 다룰 때 뿐이다.
* 중첩하지 않은 리스트의 복사는 어느 쪽이든 같다.
* 다음의 경우에 얕은 복사가 수행된다.
    * 표준 라이브러리의 copy를 이용한 복사
    * list/dict 함수를 이용한 리스트 및 딕셔너리의 복사
    * 인덱싱 혹은 슬라이싱을 사용한 복사

### 복합 객체가 아닌 경우
```py
In [1]: import copy

In [2]: a = [1, 2, 3, 4]

In [3]: b = copy.copy(a)

In [4]: a is b
Out[4]: False

In [5]: b[0] = 10

In [6]: a
Out[6]: [1, 2, 3, 4]

In [7]: b
Out[7]: [10, 2, 3, 4]
```
* 얕은 복사와 깊은 복사의 차이가 없다.

## 복합 객체인 경우
```py
In [1]: import copy

In [2]: a = [1, 2, [3, 4]]

In [3]: b = copy.copy(a)

In [4]: b[0] = 10

In [5]: a
Out[5]: [1, 2, [3, 4]]

In [6]: b
Out[6]: [10, 2, [3, 4]]

In [7]: b[2][0] = 30

In [8]: a
Out[8]: [1, 2, [30, 4]]

In [9]: b
Out[9]: [10, 2, [30, 4]]

In [10]: a[2] is b[2]
Out[10]: True
```
* 얕은 복사를 수행했다.
* b[0]을 변경했을 경우 a에는 영향이 없다.
* b[2][0]을 변경하면 a[2][0]의 데이터도 변경된다.
* 파이썬 공식 문서에 따르면 얕은 복사로 새로운 복합 객체를 만든 다음 원래 객체 안에서 찾은 객체에 대한 참조를 삽입한다고 되어 있다.
* list/dict 함수나 인덱싱 및 슬라이싱으로 생성한 복합 객체에도 적용된다.

### 깊은 복사
```py
In [1]: import copy

In [2]: a = [1, 2, [3, 4]]

In [3]: b = copy.deepcopy(a)

In [4]: b[0] = 10

In [5]: b[2][0] = 30

In [6]: a
Out[6]: [1, 2, [3, 4]]

In [7]: b
Out[7]: [10, 2, [30, 4]]
```
* 깊은 복사는 표준 라이브러리 copy의 deepcopy 함수로 수행할 수 있다.
* 깊은 복사는 완전한 사본을 만들어내므로 다른 언어에서 데이터를 복사할 때와 크게 다르지 않다.
