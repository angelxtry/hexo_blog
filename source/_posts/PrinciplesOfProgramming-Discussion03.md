---
title: 프로그래밍의 정석 독서 토론 3 - 20180109
tags:
  - 프로그래밍의정석
categories:
  - book
date: 2018-01-10 09:30:44
updated: 2018-01-10 09:30:44
---

## 토론 회고
이번 주제는 결합도를 낮추는 것, 응집도를 높이는 것 그리고 직교성에 대해 책 내용을 중심으로 토론하는 것이었습니다.

주제가 넓은 영역에 걸쳐 있고 책 범위도 넓어서 해당 내용을 여러 번 읽고 토론에 참석했는데도 부족함을 많이 느꼈습니다. 토론 시간에 여러 의견들과 질문들이 많이 나왔었는데 그 내용을 이해하기 보다는 주워담는데 급급했습니다.

그래도 토론을 하면서 전혀 생각하지 못했던 부분을 다시 한번 생각할 수 있게 된 것은 좋았습니다. 그리고 의견을 제시해 주시는 분들이 본인의 경험을 곁들여 얘기해주시는 것이 도움이 됐습니다.

무엇보다 다들 토론에 진지하게 임하고, 적극적으로 참여하려는 분위기가 좋았습니다. 그런 분위기 덕분에 토론에서 얻어가는 것이 더 많아졌다는 생각을 했습니다.

이번에도 토론에 참여하면서 스스로에게 아쉬웠던 점이 많습니다. 앞으로 책을 읽을 때 책에서 말하고자 하는 것, 내가 이해한 것을 구분해서 읽는 훈련을 하려고 합니다. 그리고 더 많은 준비와 더 많은 공부를 해야겠다고 생각했습니다.

## 토론 주제(책 내용 정리)
(토론 내용에 나오는 용어를 간략하게 정리했습니다. 간략하게 정리하다보니 비약이나 축약이 있을 수 있습니다.)

### 1. 응집도
> 모듈에 포함된 기능의 순수함을 나타내는 척도.

> 7단계. 단계가 높을수록 순수하고 강하며 좋은 모듈이다.

> * 1단계: 암합적 강도 - 우연히 생긴 모듈. 관계없는 기능이 모여 있음.
> * 2단계: 논리적 강도 - 피상적인 이유로 기능을 모은 모듈. 호출되었을 때 일부만 실행된다. 입출력 파라미터로 기능을 구분하여 사용.
> * 3단계: 시간적 강도 - 특정 시점에 실행되는 기능을 모든 모듈. ex: 초기화
> * 4단계: 순서적 강도 - 순서대로 실행되는 기능을 모든 모듈
> * 5단계: 연락적 강도 - 순서적 강도와 유사. 모듈 내에서 데이터를 교환하거나 같은 데이터를 참조.
> * 6단계: 정보적 강도 - 특정 자료구조를 다루는 여러 개의 기능을 하나로 통합. 정보적 강도 모듈과의 차이점은 진입점의 개수. 진입점을 여러 개 가지며 각 진입점은 단일 한 고유 기능을 실행.
> * 7단계: 기능적 강도 - 모듈 내 모든 명령이 하나의 역할을 실행하기 위해 서로 관련된 모듈.

### 2. 결합도
> 모듈끼리 갖는 관계의 밀접함을 나타내는 척도.

> 6단계. 단계가 높을수록 관계가 약하고 느슨한 결합이며 좋은 모듈이다. 

> * 1단계: 내용 결합 - 한 모듈과 다른 모듈이 일부를 공유. 다른 모듈 내의 외부에 선언되지 않은 데이터를 직접 참조하거나 명령의 일부를 공유.
> * 2단계: 공통 결합 - 공통 영역에 정의된 데이터(전역 변수)를 몇 개 모듈이 공동으로 사용
> * 3단계: 외부 결합 - 외부에 선언된 데이터(ex: public)를 공유
> * 4단계: 제어 결합 - 모듈의 제어를 지시하는 데이터를 파라미터로 전달하는 결합 방식
> * 5단계: 스탬프 결합 - 공통 영역에 없는 자료구조를 2개의 모듈에서 파라미터로 교환. 주고받는 자료구조의 일부를 사용하지 않을 때가 많음.
> * 6단계: 데이터 결합 - 모듈 간의 인터페이스로 스칼라형 데이터 요소만을 파라미터로 교환하는 결합 방식

## 토론 요약
* 직교성
    * 영향을 최대한 안주거나 영향이 없는 것.
    * 순수성에 가깝다. side effect가 없는 것.

* 인터페이스를 사용하면 어떤 효과를 기대할 수 있는가 -> 결합도가 낮아진다.
    * 더블 디스패치
    * 런타임에 객체를 바꿀 수 있다.

* 6단계 데이터 결합은 함수형 프로그래밍의 단게다.
    * 5단계를 개선한다고 6단계가 되지 않는다.

* 1단계 내용 결합
    * 추상 - 상속
    * 상속이 내용결합이라면 나쁜건가
    * 상속이 나쁜 것이라면 어떻게 상속을 없앨 수 있을까?
    * 모두 역할 모델로 만들어서 상속을 없엔다면 상속을 없앨 수 있을까?
    * PM or 아키텍처가 팀원들을 믿을 수 없다.
        * 부모 클래스를 만들고 작은 구현만 시킨다.
    * include의 악영향
        * include 파일 하나가 수정되면 여파가 커진다.
        * 원래 되는 줄 알았다. 사실은 include에 구현이 되어 있었다. 실제로 어떻게 돌아가는지 잘 알 수가 없다.
    * 상황에 따라 상속을 전혀 사용하지 않고 역할 모델로 구현하는 것도 좋다.
    * 상황에 따라 상속을 사용하는 것도 좋다.
    * 둘 다 사용할 줄 알아야 한다.
    * 즉, 내용결합이 나쁘지만 상황에 따라 맞게 사용하자.

* 선언형의 표현
    * 정말 좋은 건가?
    * 데이터 결합을 구현하기는 하지만
    * include도 선언이다. include의 악영향
    * 내용결합을 강화시키지 않을까?

* 결합도가 없는 프로그램은 존재하지 않는다.

* 응집도 6단계: 정보적 강도
    * 클래스는 정보적 강도를 가지고 있다.

* 응집도 7단계: 기능적 강도
    * 역할을 기준으로 메소드가 작성되어 있다.
        * ex: 로그인 클래스
    * 역할을 기준으로 응집도가 높은 클래스를 만들었을 때 자주 변경되는 메소드와 잘 사용하지 않는 메소드를 같은 클래스에 두어야 하는가?
        * 자주 변경되는 메소드가 변경 될 때 잘 사용하지 않는 메소드를 항상 테스트 해야 하는가?
        * 잘 사용하지 않는 메소드의 참조 연관성 등을 다 확인해야 하는가?
    * 하나의 역할을 수행하더라도 변경 빈도, 사용 빈도에 따라 클래스를 따로 만들 수도 있다.
        * 클래스의 메소드를 5개 이하로 분리한다.
        * 정말 꼭 필요한 메소드 만을 뽑아내면 그정도
    * 수정해야 하는 이유, 빈도, 역할이 같으면 하나의 클래스로 모은다.

* 실제로 개발하다보면 아키텍처를 고민할 여력이 없을 수도 있지 않은가?
    * 수정하거나 다시만드는 시간이 분명히 발생한다.
    * 그 시간에 아키텍처를 고민한다면?

* 아키텍트가 되기위해 가장 먼저 실천할 것
    * 코드는 두 번 나오면 함수야!
        * 코드가 두번 나오는 것을 용서하지 않는다.
        * 이렇게 하다보면 함수가 너무 많아진다.
    * 함수를 어떻게 묶어놓지?
        * 여기서 부터 설계다.
    * 결합도를 낮추고 응집도를 높인다.
    * 추상화 수준을 나눈다.
        * 처음에는 자의적으로
        * 나중에는 다른 사람의 코드를 보면서, 공부를 하면서
    * 시스템 아키텍처
        * 시스템 결합으로 무언가를 만든다.
        * ex: oracle

* 대칭성이 결합도 6단계: 기능적 강도와 대치되지 않는가?
    * 대칭성이 안지켜지는 경우가 종종 발생한다.
    * getter만 있는 경우도 많다.
    * ex: 하나의 클래스에 shift, unshift 메소드가 있다. unshift를 잘 사용하지 않는다.
        * unshift를 잘 사용하지 않으니 다른 클래스로 나눈다?
        * 대칭성이 안지켜지는건가?
    * 대칭성 보다 격리가 더 중요하다.
