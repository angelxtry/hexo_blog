---
title: 프로그래밍의 정석 독서 토론 1
tags:
  - 프로그래밍의정석
categories:
  - book
date: 2017-12-27 13:46:53
updated: 2017-12-27 13:46:53
---
# 프로그래밍의 정석 - 20171226

## 토론 회고
책의 내용을 70~80%는 이해했다고 생각했습니다. 물론 이해한 내용을 실제로 적용하는 것은 차원이 다른 일입니다. 하지만 이전에 읽었던 다른 책보다 이 책은 이해하기 쉽다고 생각했습니다.

토론을 하고나니 생각이 달라졌습니다. 내가 이해했다고 생각했던 부분들도 상당히 피상적이었습니다. 그만큼 강의나 토론이 재미있었고 유익했다고 생각합니다.

남은 부분도 열심히 읽고 토론에 참석하고자 합니다. 읽은 만큼, 이해한 만큼 얻을 수 있다는 것은 다시 한번 되새깁니다.

## 강의 요약
* 왜 이렇게 코드를 작성했는가?
    * 공격하는 사람과 방어하는 사람의 수준이 안맞으면 논쟁이 무의미하다.

* 왜 이렇게 코드를 작성했는가?
    * 구조, 함수, 클래스, 설계 등
    * 답변 1. 취향
        * 오만한 답변, 딱히 다른 이유가 없다.
    * 답변 2. 가치관
        * 조금은 거룩한 이야기
        * 정당한 이유라고 할 수 없다.
    * 답변 3. 지식
        * 알고 있는 지식은 항상 변한다.
    * 답변 4. 규칙
        * 이건 원래 이래
        * 우리가 정한 규칙이다.

* 답 : 돈, 비용
    * 돈 == 시간(개발은 대부분 인건비가 중요한 사업)
    * 돈 == 시간 == 개발 + 수정
    * 복잡성은 낮아질 수 있다.
    * 하지만 프로그램이 변한다는 규칙은 변하지 않는다.
    * 수정비용은 개발 비용은 약 8배에서 10배다.
    * 개발 비용은 디버깅 + 요건 변경 등

* 왜 이렇게 코드를 작성했는가?
    * 수정시 시간이 절약됩니다.

* 하지만...

* 내부의 반대 - 우호적인 환경
    * 얼마나 수정된다고
    * 급하니 일단 만들어
    * 유지보수는 우리가 안한다
    * 다음 버전은 딴팀이 진행한다. 등등

* 외부 - 우호적이지 않은 환경
    * 고객 요구사항
    * 일정준수
    * 프레임워크
    * 필수구현사항
    * 투입가능자원 등
    * 각 항목이 다양하고 심시어 추구하는 방향이 다르다. -> forth

* 위원회 개발
    * `맨먼스 미신`에서 언급
    * 각자의 요구사항을 모두 다 반영하여 괴물을 만든다.

* 설득과 책임
    * 이상적인 모습
    * 단일 설계 단일 책임
    * 하나의 일관된 원칙이 모든 forth에 적용

* 다시 한번 왜 이렇게 코드를 작성했는가?
    * 보다 구체적이고 강력한 방향성!
    * 원리 -> 원칙 -> 가치 -> 철학
    * 원리는 원칙을 위반하면 안된다.
    * 원칙은 가치를 위반하면 안된다.
    * 충분한 지식이 있다면 원리를 언급하는 것 만으로도 답이 될 수 있다.
    * 원리로 부족하다면 원칙을 논의하자.
    * 원칙으로 부족하다면 가치를 논의하자.

* 원리
    * 개발자라면 원리에 대한 얘기가 통하지 않을까?
    * 추상
    * 캡슐화
    * 은닉
    * 패키지
    * 관심의 분리
    * 완전성, 순수성
    * 정책과 구현
    * 인터페이스와 구현
    * 단일 참조
    * 분할 정복
    * 대화 참여자가 비슷한 수준의 지식이 필요하다.
    * 지식 수준이 비슷하더라도 논쟁의 여지가 있다.
        * ex) 추상화(모델링, 일반화(categorize), 그룹화)
    * 원리만으로 왜 이렇게 코드를 작성했는가를 논의하고 결론을 낼 수 있다면 가장 행복항 상황
    * 원리 단계에서 논의할 수 있을만큼 팀의 수준을 높이자.

* 원칙
    * 규칙 - 우리들이 정한 것
        * 원칙을 지키고 있으면 예외를 바로 알 수 있다.(ex: 코딩컨벤션)
        * 코딩 컨벤션을 안지켜도 프로그램이 깨지지 않지만 준수하면 효과를 볼 수 있다.
    * 결과의 국소화
    * 반복의 최소화
    * 로직과 데이터의 일체화
    * 대칭성
    * 선언형 표현
    * 변경빈도
    * '이것이 규칙이다!'라고 그냥 우기면 싸운다.
    * 원칙을 기준으로 삼고 규칙을 만드는 것이 덜싸운다.

* 원칙-선언형 표현
    * 품질을 어느 정도 수준까지 맞춰주지만...
    * 제대로 이해하지 못하고 너무 과도하게 사용하면 멍청해지는 부작용

* 가치
    * 의사소통
    * 단순성
    * 유연성
    * 단순한 것이 유연하다.

* 가치의 기저
    * 철학
    * 철학의 양단에 합리주의와 상대주의가 있다.
    * 합리주의 - 기준을 제시한다.
    * 상대주의 - 상황에 맞게

## 토론 - 정답이 아니라 의견임
* 어떻게 문서화를 하는가?
    * git commit 시점에 코드와 문서를 같이
    * 주석을 없애자.
    * git history를 문서처럼 

* 새로운 기술을 도입하려고 할때 어떻게 해야 할까?
    * 다른 팀원이 새로운 기술에 적응해서 기존과 비슷한 속도와 질을 보장할 수 있을까?
    * project의 일부를 fork, 신기술을 적용하여 best practice까지 만드 후에...
    * 마이크로 서비스 아키텍처가 답일수도...

* DRY
    * 시간이 지나면 중복이 계속 발견된다.
    * 내가 발전해서 또는  프로젝트가 진행되는 과정에 자연스럽게.
    * 중복을 발견하는 시점에서 중복을 제거하는 것이 비용이 가장 싸다.
    * 팀을 나눠서 offense, defense 역할을 구분한다.
        * offense: new feature 만 처리한다.
        * defense: 작성된 코드를 보수하고, refactoring 한다.
        * 양 팀의 팀원을 계속 교체하여 이해를 빠르게 한다.
        * offense, defense 팀을 교체한다.
        * offense 쪽이 훨씬 스트레스가 심하다.
        * 스트레스가 높아지면 창발력이 높아진다.
        * 동시에 엄청나게 부주의해진다.
        * 예전에는 이것을 부정적으로 생각했지만 요즘은 offense, defense 팀을 동시에 운용하는 것이 효과적이라고 생각한다.
        * 동료를 구할 때 보통 offense 역할을 찾으려 하지만 실패할 확률이 높다.
        * 본인이 offense를 하고 defense를 구하는 것이 훨씬 쉽다.
        * 일정기간 뒤에 로테이션(!)
    * 나 혼자 기간을 구분하여 offense와 defense를 번갈아 진행한다.

* 읽기 좋은 코드
    * 역할을 수행하는 것들끼리 메시지로 대화하는 경우 가장 이해하기 쉽다.
    * 역할 모델로 개발을 할 수 있는가, 그만한 능력이 되는가.
    * 단순하게 유틸리티의 집합으로 만들어라.
    * 역할 모델을 설계할 수 없다면 단순하게 만들고 조합하자.
    * 팀이 문제를 해결하는 경우는 극히 드물다.
    * 아키텍쳐를 데리고 오는 것이 가장 빠른 해결 방법이다.
    * 이키텍쳐를 데려 올 수 없다면?
    * 본인이 해당 분야의 아키텍쳐 수준까지 올라가자.

* OCP
    * 팀원들이 OCP를 이해한다면 개발하는 프로그램을 부분 확장하는 방식으로 빠르고, 유연하게 개발할 수 있다.
    * 더블 디스패치가 가능하도록 코드를 작성하자.

* 명명법
    * 사내 딕셔너리를 만든다.
    * 코드를 만들면서 딕셔너리도 완성되어간다.

## 감상

책을 읽으면서 프로그래밍의 가장 중요한 요소는 다른 사람이 얼마나 이해하기 쉽게 코드를 작성하는가 라는 생각이 들었습니다. 유지보수성도 결국은 이해하기 쉬운 코드의 하위호환이라고 생각합니다.

시작하며에 적혀있는 것 처럼 특정 언어나 기술에 대해 설명하는 책들은 문법이나 팁에 대해 알려줄 수는 있지만 자신의 프로그램 실력이 나아진다는 생각이 들지는 않습니다. 유명한 프로그램 이론서들은 제 수준에서는 많이 어렵고 직접적으로 와 닿지 않았습니다. 이 책은 그 사이에 위치해 있는 것 같습니다. 잘 읽히고, 잘 이해됩니다. 왜 그래야 하는지 쉽게 알려주는 것 같습니다.

아직 실제 코드에 적용해보지는 못했지만 예전에 작성한 코드들을 떠올리면서 '그렇게 작성한 건 잘못되었구나...' 하는 생각을 계속 떠올릴 수 있었습니다.

책을 읽어보면 한 번쯤은 다 들어본 얘기일겁니다. 하지만 다 외우고 있지는 못하죠. 이 책은 그 구슬들을 잘 꿰어놓았습니다. 적당한 타이틀을 붙여놓고 순서를 잘 조합해서 늘어놓으니 서로 같은 얘기를 하고 있다는 것도, 이것과 이것은 비슷하지만 조금은 다른 얘기라는 것도 알 수 있게 도와줍니다.

읽으면서 좋았던 부분을 정리해보자면 `1.2 코드는 설계서다.` 라는 부분을 보면, 한번도 코드는 결과물이라고 생각했지 코드 자체가 설계서라고 생각하지는 못한 것 같습니다. 설계를 이정도로 했으면 코드를 작성할 때 알아서 처리해야지 하고 생각했던 적도 많았었고, 설계가 왜 이따위야 라고 생각했던 적도 많았는데 사실 생각해보면 그건 하나의 과정이었던거죠.

`2.6 OCP` 같은 것도 '지나치게 예측하지 말아야 한다. 변경 내용을 예측하기 보다 변화할 법한 부분을 예측하는 거다.' 이런 내용이 다른 책의 OCP 설명에서는 못봤던 것 같습니다. 물론 제가 이해를 못했거나 기억이 나지 않는 걸 수도 있습니다.

`3.10 변경 빈도`와 SRP를 엮어서 설명하는 부분도 좋았습니다. 얼마나 자주 변경되느냐도, 어느 시점에 같이 변경되느냐도 같이 생각해야 한다는 것. 이것은 결국 단일 책임의 원칙으로 연결된다는 것도 지식이 얕은 저에게는 많은 도움이 됐습니다.

그리고 '정책과 구현의 분리', '인터페이스와 구현의 분리' 이런 것은 이름이 비슷해서 헷갈리는 항목들인데 붙여놓아서 명확하게 이해하고 기억할 수 있게 같이 정리해두어서 좋았습니다.

이 책에서는 소프트웨어는 본질적으로 난해하다고 주장합니다. 그것을 1. 복잡성, 2. 동조성, 3. 가변성, 4. 비가시성 4가지로 정리하여 설명합니다.

이 중에서 특히 3. 가변성과 4. 비가시성이 많이 와 닿았습니다. 개발보다 기획쪽에 치우쳐서 일을 해보면 소프트웨어가 완성된 후에 좀 더 나은 개선사항이 나오는 것을 종종 겪었습니다. 기획의 부족함일 수도 있겠지만 여기서 말하는 가변성일 수도 있겠다라는 생각이 듭니다.

비가시성을 읽으면서 처음 개발을 시작했을 무렵에 코드를 읽는 것이 너무 고통스러워서 다이어그램을 이용해 깔끔하게 표현하는 방법이 없을까 고민을 했었던 기억이 떠올랐습니다. 코드의 양이 일정량 이상이 되거나 여러 사람의 손을 거친 코드는 결국 모두 이해한 후 다시 고쳐쓰는 수 밖에 없다는 것은 나중에야 깨닫게 되었습니다.
